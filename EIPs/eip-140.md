# EIP-140: REVERT instruction


## 요약
`REVERT` 는 실행을 중지하고 지금까지 수행한 모든 상태 변경을 롤백하며 오류 코드 또는 메시지로 해석될 수 있는 메모리 섹션에 대한 포인터를 제공합니다. 
이 과정에서 남은 가스를 모두 소모하지 않습니다.

`REVERT` 는 `비잔티움 하드 포크` 때 추가되어 2017년 3월 부터 지원되었습니다.

## EIP 제안 동기
`REVERT` 가 제안되기 전에는 아래 두 방법으로 트랜잭션의 실행을 되돌릴 수 있었습니다.
- gas 가 부족한 경우
- 유효하지 않은(invalid) instruction 을 실행하는 경우

하지만, 두 경우 모두 남은 가스를 모두 소모하도록 동작했고 트랜잭션의 실행이 되돌려지면 문제가 발생한 지점의 LOG 까지도 손실되기 때문에 오류 코드 또는 메세지로 해석될 수 있는 정보를 알 수 없었습니다.

따라서, 모든 gas 를 소모하지 않으면서도 문제 발생 시 LOG 를 남길 수 있는 방법으로써 제안되었습니다.

## 선정 이유
`Solidity`로 작성된 프로그램에서 `EVM`의 상태를 되돌리는 방법으로는 `assert()`, `require()`, `revert()`의 세 가지가 있습니다.
- `assert(<조건문>)`
    - OpCode(*0xfe*) 를 사용하여, `Panic(uint256)` type 의 에러를 발생시킴
    - 모든 gas 를 소모
- `require(<조건문>, "에러메세지")`
    - OpCode(*0xfd*) 를 사용
    - gas 가 환불됨
- `revert("에러메세지")`
    - OpCode(*0xfd*) 를 사용
    - gas 가 환불됨

이에 대해 어떤 차이점이 있는지 자세히 살펴보고 싶어 찾아보게 되었습니다.

## 본론
아래와 같이 [`params/config.go`](https://github.com/orakle-opensource/EIP_opensource/blob/master/params/config.go#L50) 에 명시된 `ByzantiumBlock` 이후의 블록부터는 [`core/vm/opcodes.go`](https://github.com/orakle-opensource/EIP_opensource/blob/master/core/vm/opcodes.go#L222) 에 명시된 `REVERT` (*0xfd*) OpCode 를 사용할 수 있습니다.
```go
// 0xf0 range - closures.
const (
	CREATE       OpCode = 0xf0
	CALL         OpCode = 0xf1
	CALLCODE     OpCode = 0xf2
	RETURN       OpCode = 0xf3
	DELEGATECALL OpCode = 0xf4
	CREATE2      OpCode = 0xf5

	STATICCALL OpCode = 0xfa
	// REVERT 는 OpCode 값으로 `0xfd` 를 가짐
	REVERT       OpCode = 0xfd
	INVALID      OpCode = 0xfe
	SELFDESTRUCT OpCode = 0xff
)
```

`REVERT` 는 트랜잭션에 의한 실행을 실패로 간주하여 중단하고, EVM 의 상태 변화를 다시 롤백합니다.
또한, 일반적인 반환값(return data)를 다룰 때와 동일하게 에러 메세지를 반환합니다.

`REVERT` 는 스택 상의 두 값을 각각 `memory_offset`, `memory_length`로 사용합니다.
수행을 중단하기 때문에 스택에 다른 정보를 추가하지는 않습니다.
`memory`에는 에러 메세지가 저장되어 있으며, 이렇게 메모리를 이용할 때의 cost 는 `RETURN` 에서와 동일합니다.

아래와 같이 [`core/vm/instructions.go`](https://github.com/orakle-opensource/EIP_opensource/blob/master/core/vm/instructions.go#L789-L795)에서 이를 구현하고 있습니다.
```go
var (
	MainnetTerminalTotalDifficulty, _ = new(big.Int).SetString("58_750_000_000_000_000_000_000", 0)

	// MainnetChainConfig is the chain parameters to run a node on the main network.
	MainnetChainConfig = &ChainConfig{
		ChainID:        big.NewInt(1),
		HomesteadBlock: big.NewInt(1_150_000),
		// EIP-779, TheDAO hard-fork 가 적용되는 블록이 1,920,000 임을 명시합니다.
		DAOForkBlock:                  big.NewInt(1_920_000),
        // ...
		ByzantiumBlock:                big.NewInt(4_370_000),
        // ...
    }
    // ...
)
```

```go
// REVERT instruction 을 수행하는 함수
func opRevert(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) {
	// EVM 의 stack 을 두 번 pop 하여 `offset`, `size` 값으로 사용합니다.
	offset, size := scope.Stack.pop(), scope.Stack.pop()

	// `offset`, `size` 를 이용하여 메모리 상의 특정 포인터를 가져옵니다.
	ret := scope.Memory.GetPtr(int64(offset.Uint64()), int64(size.Uint64()))

	// interpreter 에 마지막으로 호출한 함수의 반환값을 저장합니다.
	interpreter.returnData = ret

	// `ret`, 프로그램 수행이 REVERT 되었다는 에러 메세지를 반환합니다.
	return ret, ErrExecutionReverted
}
```

만약 `REVERT` 를 수행하기에 부족한 gas 를 갖고 있거나 스택 언더플로우가 발생했을 경우에는 일반적인 `가스 부족` 상황과 동일한 결과로 이어집니다.

다른 수행 실패(failure)들과 마찬가지로, 호출 OpCode 는 호출자의 `REVERT` opcode에 이어 스택에 `0`을 반환합니다.

`CREATE` 또는 `CREATE2` 호출의 컨텍스트에서 `REVERT`가 사용되는 경우 코드가 배포되지 않고 스택에 `0`이 저장되며
에러 메세지가 반환 데이터 버퍼(returndata buffer)에서 사용할 수 있습니다.

## Reference
https://eips.ethereum.org/EIPS/eip-140

https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement

https://velog.io/@pier101/%EC%88%98%EC%A0%95%ED%95%84%EC%9A%94Solidity-%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC1-revert-require-assert
