# # EIP-3529: Reduction in refunds


## 요약
`SELFDESTRUCT` 에서 *가스 환불* 을 제거하고 `SSTORE` 에서는 *가스 환불* 정도를 낮춤으로써, “exploit” 가 가능한 현재의 환불 정책을 수정합니다.

## EIP 제안 동기
`SELFDESTRUCT` 와 `SSTORE` 에 *가스 환불* 이 제안된 최초의 동기는 어플리케이션 개발자들이 “깔끔한 상태”의 어플리케이션을 작성하도록 동기를 부여하기 위해서였습니다. 여기서 “깔끔한 상태”란 더 이상 필요없는 저장소 슬롯과 컨트랙트를 비우는 것을 말합니다. 하지만, 이러한 기술은 기대보다 훨씬 낮은 결과를 보여주었고 심지어 *가스 환불* 은 아래와 같은 다양한 의도되지 않은 결과로 이어지기도 했습니다.
- *가스 환불* 은 **GasToken** 을 등장시킵니다.
  - `GasToken`은 낮은 수수료 기간에 가스를 구매하여 높은 수수료 기간에 사용함으로써 전체적인 트랜잭션 비용을 절감하는 메커니즘을 제공합니다. 이는 마치 '가스 저장 배터리'처럼 작동하며, 사용자가 비용이 낮은 시기에 가스를 사서 비용이 높은 시기에 활용할 수 있게 합니다.
  - 그러나 이 과정에서 `GasToken`을 저장하기 위해 필요한 상태 데이터가 증가하게 되어 **상태 크기가 커지는 문제**가 발생합니다. 또한, `GasToken`의 생성과 소멸 과정에서 상당량의 가스가 소모되어 **네트워크의 전체적인 가스 사용 효율이 저하됩니다**. 이러한 문제들은 네트워크의 성능에 부정적인 영향을 미칩니다.
- *가스 환불* 은 블록 크기의 변동성을 증가시킵니다.
  - 이더리움 블록체인에서 각 트랜잭션은 특정 양의 가스를 소비하고, *가스 환불* 은 소비된 가스의 일부를 다시 환불해주는 기능을 합니다. 환불은 트랜잭션이 소비한 가스의 최대 50%까지 가능하다는 제한이 있습니다. 또, 각 블록에 대해서도 처리할 수 있는 가스의 한도가 있습니다. 이는 너무 많은 가스를 소비하지 않도록 제한하는 것입니다.
  - *가스 환불* 이 다음 트랜잭션에 추가적인 가스 공간(가스가 더 소비될 수 있는 가능성)을 제공하기 때문에, 이론적으로 한 블록에서 실제로 소비될 수 있는 가스의 양은 블록에 명시된 가스 한도의 거의 두 배에 이를 수 있습니다. 결과적으로, 한 블록 내에서 트랜잭션이 소비할 수 있는 가스의 양이 기대치보다 훨씬 높을 수 있으며, 이는 블록 크기의 변동성을 크게 증가시킵니다.
  - 이러한 변동성은 치명적이진 않습니다. 하지만, EIP-1559 가 도입되면서 블록당 가스 한도가 시장 매커니즘에 따라 동적으로 조정되는데, 환불을 통해 사용 가능한 가스가 증가하면 이로 인해 2배에 가까운 사용량 증가가 길게 유지될 수 있습니다. 따라서, EIP-1559의 도입 목적인 *블록 가스 사용의 더 정확한 조절과 예측 가능성 향상* 에 반하는 결과를 초래할 수도 있습니다. 이러한 문제는 네트워크 효율성과 안정성을 저하시킬 수 있습니다.

따라서,  `SSTORE` 와 `SELFDESTRUCT` EVM opcode 를 수정하여 이러한 *가스 환불* 에 관한 문제들을 해결하고자 합니다.

## 선정 이유
네트워크 안정성을 위해 도입된 'gas fee'나 'refund'와 같은 경제학적 개념들이 매우 생소합니다. 이번 기회에 이들 개념에 대해 이해해보고자 합니다.

## 본론
`London hard fork` 에 해당하는 $12,965,000$ 번째 블록 이후부터 아래의 변화들이 적용됩니다.
1. `SELFDESTRUCT` 에 대한 **환불** 메커니즘이 제거
2. `SSTORE` 에 대한 **환불 값** 조정
- [EIP-2200](https://eips.ethereum.org/EIPS/eip-2200) 에서 정의된 `SSTORE_CLEARS_SCHEDULE` **환불 값** 을 `SSTORE_RESET_GAS - COLD_SLOAD_COST + ACCESS_LIST_STORAGE_KEY_COST` 로 변경합니다. 
이는 $4,800$ 이며 [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929) 에서의 `COLD_SLOAD_COST` $(=2,100)$ 와 [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) 에서의 `ACCESS_LIST_STORAGE_KEY_COST` $(=1,900)$를 아래와 같이 반영한 결과입니다.

$$
\begin{align}
  &\text{SstoreResetGas} - \text{ColdSloadCost} + \text{AccessListStorageKeyCost} \newline
  &= 5,000 - 2,100 + 1,900 \newline
  &= 4,800
\end{align}
$$

3. 트랜잭션 수행 후 환불되는 **최대 가스량** 조정
- **최대 환불 가스량**은 아래와 같습니다. *MaxRefundQuotient* 값을 $2$ 에서 $5$ 로 증가시킴으로써 환불되는 가스량을 감소시킵니다.

$$
\begin{align}
\text{MaxRefundGas} = \lfloor\frac{\text{GasUsed}}{\text{MaxRefundQuotient}}\rfloor
\end{align}
$$

### 환불 조정에 관한 근거
[EIP-2200](https://eips.ethereum.org/EIPS/eip-2200#specification) 에서 아래 세 경우의 **환불**이 제안되었습니다.

1. 기존의 값이 $0$이 아니고 새로운 값이 $0$일 경우
   - `SSTORE_CLEARS_SCHEDULE` 가스 값(현재 $15,000$) 을 *refund counter* 에 더합니다.
2. 기존의 값이 $0$이고 현재 값이 $0$이 아닐 때, 그리고 새로운 값이 $0$인 경우
   - `SSTORE_SET_GAS - SLOAD_GAS` 가스 값(현재 $19,900$) 을 *refund counter* 에 더합니다.
3. 기존의 값이 $0$이 아니고 현재의 값이 기존의 값과 다른 $0$이 아닌 값일 때, 그리고 새로운 값이 기존의 값과 동일한 경우
   - `SSTORE_RESET_GAS = SLOAD_GAS` 가스 값(현재 $4,900$) 을 *refund counter* 에 더합니다.

여기서 ‘기존의 값’, ‘현재 값’, ‘새로운 값’은 [EIP-2200](https://eips.ethereum.org/EIPS/eip-2200#motivation)의 맥락에서 사용된 단어이며, 스토리지 슬롯의 값을 의미합니다. 스토리지의 슬롯 값이 비어있으면($0$ 인 경우) 가스 환불을 받을 수 있습니다.

우선 (2), (3) 경우에 대해 살펴보고 (1)에 대해 살펴보도록 하겠습니다.

#### (2) 0 -> ~0 -> 0
이더리움에서 스토리지를 사용할 때, 스토리지 슬롯에 데이터를 설정하거나 변경하는 데는 가스가 소비됩니다. 특히, 특정 스토리지 슬롯의 값이 $0$에서 $0$이 아닌 값으로 변경될 때는 일반적으로 높은 가스 비용이 듭니다. 즉, `SSTORE_SET_GAS` (=$20,000$) 라는 가스 비용이 부과됩니다.

(2)의 경우는 스토리지 슬롯이 처음에 비어있다가 트랜잭션 실행 과정 중 슬롯에 데이터를 저장하게 되고, 트랜잭션이 완료된 후에는 다시 슬롯을 비우는 상황입니다.

따라서, 스토리지 슬롯을 처음에 $0$ 에서 변경하면 약 $20,000$ 가스가 소비됩니다. 그리고 나중에 이 값을 다시 $0$으로 되돌리면, `SSTORE_SET_GAS - SLOAD_GAS` (=$19,900$) 만큼의 가스를 환불 받을 수 있습니다.

이 과정에서 환불받는 가스량이 처음에 소비한 가스량보다 거의 같고 오히려 적기 때문에 `GasToken` 을 사용할 수 없습니다. `GasToken` 은 지불한 가스보다 환불받을 수 있는 가스량이 상대적으로 높을 때 유용합니다. 따라서, (2)의 경우는 큰 문제가 되지 않습니다.

#### (3) ~0 -> ~0’ -> ~0
스토리지 슬롯에 대한 ‘재설정’ 작업은 `SSTORE_RESET_GAS` 비용이 부과됩니다. 트랜잭션 수행 완료 후 처음의 상태로 되돌아 온 경우 `SSTORE_RESET_GAS - SLOAD_GAS` ($=4,900$) 만큼의 가스를 환불받을 수 있습니다. [EIP-2200](https://eips.ethereum.org/EIPS/eip-2200#specification) 에서 정의한대로 `SSTORE_RESET_GAS` 는 $5,000$ 만큼의 가스를 소비합니다. 따라서, (2) 와 비슷한 이유로 큰 문제가 되지 않습니다.

#### (1) ~0 -> 0
스토리지 슬롯의 원래 값이 $0$ 이 아닌 상태에서 $0$으로 변경될 때의 환불 상황입니다. 여기서 **Pairing** 의 개념을 활용할 수 있습니다. 이는 스토리지 슬롯의 값이 변경될 때 발생하는 **비용** 과 나중에 그 슬롯을 변경함으로써 발생하는 **환불** 을 연결짓는 것입니다. (1) 에서의 상황은 아래 두 경우로 나누어 생각할 수 있습니다.

1. 처음으로 스토리지 슬롯이 $0$ 이 되는 경우
   - 이 상황에서는 스토리지 슬롯을 처음 읽고 수정하는 데 드는 **비용**인 `SSTORE_RESET_GAS`, `ACCESS_LIST_STORAGE_KEY_COST` 와 이에 따른 **환불**(`SSTORE_CLEARS_SCHEDULE`)을 짝지어 생각합니다. 
2. 두 번째 또는 그 이후에 스토리지 슬롯이 $0$ 이 되는 경우
   - 이 상황에서는 가장 최근에 슬롯이 $0$ 으로 된 **이벤트**와 이전에 슬롯 값이 $0$이 아닌 값으로 설정되었을 때의 **비용**을 짝지어 생각합니다. **환불**(`SSTORE_CLEARS_SCHEDULE`)은 해당 **비용** 과 정확히 일치하므로, 추가적인 가스 이득이 없습니다.

두 번째 이후에 스토리지 슬롯이 $0$ 이 되는 경우에는 해당 슬롯에 있던 데이터 사이즈만큼을 설정할 때 든 비용을 그대로 환불받기 때문에 `SSTORE_CLEARS_SCHEDULE` 의 값은 중요하지 않습니다. 따라서, 지불되는 가스 비용을 양의 값으로 하고 싶다면 첫 번째로 슬롯이 $0$이 되는 경우의 **비용** 및 **환불**을 고려하여 아래와 같은 수식을 생각할 수 있습니다.

$$
\begin{align}
\text{SstoreClearsSchedule} \le \text{SstoreResetGas} + \text{AccessListStorageKeyCost}
\end{align}
$$

따라서, 본 EIP (EIP-3529) 를 적용하면 아래와 같이 **환불 값** 을 조정하게 됩니다.


$$
\begin{align}
\text{SstoreClearsSchedule} = \text{SstoreResetGas} + \text{AccessListStorageKeyCost}
\end{align}
$$

EIP-3529 는 특히 두 번째 이후로 스토리지 슬롯이 $0$으로 설정될 때의 환불 규칙에 대한 변경을 제안합니다. (2)의 경우 **환불** 금액인 `SSTORE_CLEARS_SCHEDULE` 은 이전에 해당 슬롯에 $0$이 아닌 값을 설정했을 때의 **비용** 과 일치합니다. 즉, 환불받는 가스는 지출한 비용과 동일하므로 추가적인 가스 이득이 없습니다.

### 이전 버전과의 호환성
**환불**은 트랜잭션의 수행이 끝난 후에만 적용되므로, 실행 중인 특정 호출 프레임에서 사용 가능한 가스 양에 영향을 미치지는 않습니다. 따라서, **환불** 을 제거해도 코드 실행에는 영향을 주지 않겠지만 일부 어플리케이션은 경제적으로 실행이 불가능해질 수도 있습니다.
`GasToken`은 가치가 없어질 것입니다. 현재 많은 DeFi (분산 금융) 자동화 봇들이 이미 설정된 `GasToken` 스킴이나 맞춤형 대안을 사용하여 온체인 비용을 줄이고 있지만, 이제는 더 이상 기능하지 않는 가스 저장 메커니즘에 대한 호출을 제거하기 위해 코드를 재작성하는 것이 좋습니다.
하지만, **환불** 정책을 아예 제거하는 것은 아닙니다. 몇 가지 주요 사례에서는 여전히 기존 방식대로 가스 비용 처리를 하게 됩니다. 예를 들어, $0 \rightarrow \neg 0 \rightarrow 0$ 과 같은 패턴에서 여전히 가스는 $100$만 소비됩니다. *몇 가지 주요 사례* 는 아래와 같습니다.
1. `Anti-Reentrancy Lock`
   - 자식 호출이 시작되기 전에 바로 $0 \rightarrow 1$ 로 상태가 전환됩니다.
   - 자식 호출이 종료되면 $1 \rightarrow 0$ 로 상태가 돌아옵니다.
   - 이렇게 잠금 상태를 변경함으로써, 재진입 공격을 방지할 수 있습니다.
2. `ERC20 approve-and-send`
   - 사용자가 토큰을 전송하기 전에 먼저 해당 수량을 승인해야 합니다.
   - *승인된 값* 은 토큰 전송이 승인될 때 $0 \rightarrow \neg 0$로 변경됩니다.
   - 토큰 전송이 처리되면 다시 $\neg 0 \rightarrow 0$ 이 됩니다.
   - 이러한 메커니즘을 이용해 자신의 토큰을 안전하게 다른 주소로 옮길 수 있습니다.

### 스토리지 clearing incentives 에 대한 영향
…


## Conclusion

---
## Reference
https://eips.ethereum.org/EIPS/eip-3529

https://ethereum.org/en/history/#london

